#!/bin/bash
set -e


# ------------------------------------ VARIABLES GLOBALES ------------------------------------

readonly VERSION="0.4.2"

# Colores
readonly RED='\033[0;31m'
readonly YELLOW='\033[1;33m'
readonly CYAN='\033[0;36m'
readonly WHITE='\033[1;37m'
readonly NC='\033[0m'

# Rutas base para temporales (opcional, pero mejora la consistencia)
readonly TMP_BASE="/var/tmp"

# URLs y rutas
readonly REPO_URL="https://raw.githubusercontent.com/Guido-Romano/redcrack/main/usr/bin/redcrack"
readonly INSTALL_PATH="/usr/bin/redcrack"
readonly TMP_PATH="${TMP_BASE}/redcrack_latest.sh"

readonly OUI_PATH="/usr/share/redcrack/oui.txt"
readonly TMP_OUI="${TMP_BASE}/oui_latest.txt"
readonly OUI_URL="https://standards-oui.ieee.org/oui/oui.txt"

XML_FILE="${TMP_BASE}/captura-01.kismet.netxml"
readonly TMP_DIR="${TMP_BASE}" # Definimos TMP_DIR para usarlo con airodump-ng


# -------------------------------- COMPROBACION DE ACTUALIZACIONES DEL SCRIPT --------------------------------

if [[ "${BASH_SOURCE[0]}" == "${0}" ]]; then
    echo -e "${CYAN}[RedCrack] Verificando actualizaciones del script...${NC}"

    current_hash=$(sha256sum "$0" | awk '{print $1}')

    if curl -fsSL "$REPO_URL" -o "$TMP_PATH"; then
        remote_hash=$(sha256sum "$TMP_PATH" | awk '{print $1}')

        if [[ "$current_hash" != "$remote_hash" ]]; then
            echo -e "${YELLOW}[RedCrack] Se encontró una nueva versión disponible.${NC}"
            read -p "$(echo -e "[RedCrack] ¿Deseás actualizar e instalar la última versión? (s/N): ")" confirm

            if [[ "$confirm" =~ ^[sS]$ ]]; then
                sudo cp "$TMP_PATH" "$INSTALL_PATH"
                sudo chmod +x "$INSTALL_PATH"
                echo -e "${CYAN}[RedCrack] Actualización completada. Ejecutando nueva versión...${NC}"
                exec "$INSTALL_PATH"
            else
                echo -e "${CYAN}[RedCrack] Actualización cancelada por el usuario.${NC}"
            fi
        else
            rm -f "$TMP_PATH"
            echo -e "${CYAN}[RedCrack] Ya estás usando la última versión.${NC}"
        fi
    else
        echo -e "${RED}[RedCrack] No se pudo verificar actualizaciones.${NC}"
    fi
fi


# ------------------------------------------ BANNER ------------------------------------------

echo
echo -e "${RED}"
cat << "EOF"
                                 88                                                  88         
                                 88                                                  88         
                                 88                                                  88         
8b,dPPYba,   ,adPPYba,   ,adPPYb,88   ,adPPYba,  8b,dPPYba,  ,adPPYYba,   ,adPPYba,  88   ,d8   
88P'   "Y8  a8P_____88  a8"    `Y88  a8"     ""  88P'   "Y8  ""     `Y8  a8"     ""  88 ,a8"    
88          8PP"""""""  8b       88  8b          88          ,adPPPPP88  8b          8888[      
88          "8b,   ,aa  "8a,   ,d88  "8a,   ,aa  88          88,    ,88  "8a,   ,aa  88`"Yba,   
88           `"Ybbd8"'   `"8bbdP"Y8   `"Ybbd8"'  88          `"8bbdP"Y8   `"Ybbd8"'  88   `Y8a  
EOF
echo
echo -e "${WHITE}                                                              By apocca v$VERSION"
echo
echo
echo "#############################################################################################"
echo "#                                                                                           #"
echo "#  IMPORTANTE: Herramienta para Pruebas de Penetración en Redes Wi-Fi                       #"
echo "#                                                                                           #"
echo "#  Este software ha sido desarrollado para realizar pruebas básicas de                      #"
echo "#  penetración en redes inalámbricas que utilizan los protocolos WPA2 o                     #"
echo "#  anteriores. Incorpora funcionalidades como la ejecución de Aircrack-ng,                  #"
echo "#  la consulta del archivo OUI y la descarga automatizada de dependencias.                  #"
echo "#                                                                                           #"
echo "#  El uso de esta herramienta debe realizarse con absoluta responsabilidad y                #"
echo "#  exclusivamente en redes propias o en entornos de laboratorio debidamente                 #"
echo "#  autorizados. Queda terminantemente prohibido su uso sin el consentimiento                #"
echo "#  explícito del propietario de la red.                                                     #"
echo "#                                                                                           #"
echo "#  El desarrollador no se hace responsable del uso indebido o ilegal que                    #"
echo "#  pueda darse a esta herramienta. La responsabilidad recae completamente                   #"
echo "#  en el usuario final.                                                                     #"
echo "#                                                                                           #"
echo "#############################################################################################"
echo -e "${NC}"
echo


# -------------------- VERIFICACION AUTOMÁTICA SILENCIOSA DEL ARCHIVO OUI --------------------

local_oui_hash=""
if [[ -f "$OUI_PATH" ]]; then
    local_oui_hash=$(sha256sum "$OUI_PATH" | awk '{print $1}')
fi

if curl -fsSL "$OUI_URL" -o "$TMP_OUI"; then
    remote_oui_hash=$(sha256sum "$TMP_OUI" | awk '{print $1}')

    if [[ "$remote_oui_hash" != "$local_oui_hash" ]]; then
        sudo mkdir -p "$(dirname "$OUI_PATH")"
        sudo mv "$TMP_OUI" "$OUI_PATH"
    else
        rm -f "$TMP_OUI"
    fi
fi


# --------------------------------------- ACTIVAR MODO MONITOR ---------------------------------------

# Comprobacion de modo monitor

INTERFAZ=$(airmon-ng | awk 'NR>2 && $1!="" {print $2; exit}')



if [ -z "$INTERFAZ" ]; then
    echo -e "${RED}No se encontró ninguna interfaz inalámbrica.${NC}"
    exit 1
fi

if ! iwconfig "$INTERFAZ" 2>/dev/null | grep -q "Mode:Monitor"; then
    echo -e "${YELLOW}La interfaz $INTERFAZ no está en modo monitor. Configurando...${NC}"
    sudo airmon-ng check kill > /dev/null 2>&1
    sudo airmon-ng start "$INTERFAZ" > /dev/null
    INTERFAZ_MONITOR=$(iwconfig 2>/dev/null | awk '/Mode:Monitor/ {print $1}' | head -n1)
    
    if [ -z "$INTERFAZ_MONITOR" ]; then
        echo -e "${RED}Fallo al activar modo monitor.${NC}"
        exit 1
    fi
else
    INTERFAZ_MONITOR="$INTERFAZ"
fi

echo -e "${NC}Interfaz en modo monitor: $INTERFAZ_MONITOR${NC}"

mkdir -p "$TMP_DIR"
rm -f "$TMP_DIR"/captura-*


echo -e "${YELLOW}Abriendo airodump-ng en esta terminal...${NC}"
airodump-ng "$INTERFAZ_MONITOR" --band abg --write "$TMP_DIR/captura" --output-format netxml &

AIROD_PID=$!

read -p "Presioná ENTER cuando quieras procesar los resultados..."

kill "$AIROD_PID"
sleep 2

# Buscar el archivo .netxml generado
XML_FILE=$(find "$TMP_DIR" -type f -name "*-01.kismet.netxml" | head -n1)

# Mostrar si se encontró algo (debug)
if [ -z "$XML_FILE" ]; then
    echo -e "${RED}Error: El archivo de captura no se generó correctamente.${NC}"
    echo -e "${YELLOW}[Debug] Contenido de $TMP_DIR:${NC}"
    ls -lh "$TMP_DIR"
    exit 1
fi

# Eliminar cualquier referencia a DTD para evitar errores de procesamiento
sed -i '/<!\(DOCTYPE\|ENTITY\).*>/d' "$XML_FILE"

# Asegurarnos que el archivo existe y es legible
if [ ! -r "$XML_FILE" ]; then
    echo -e "${RED}Error: No se puede leer el archivo $XML_FILE${NC}"
    exit 1
fi

# Verificar que el archivo XML es válido
if ! xmlstarlet val -w "$XML_FILE" > /dev/null 2>&1; then
    echo -e "${YELLOW}Advertencia: El archivo XML podría no ser válido. Intentando repararlo...${NC}"
    # Eliminamos líneas problemáticas y nos aseguramos de tener un XML bien formado
    # Creamos un archivo temporal
    TMP_XML="${TMP_DIR}/temp_fixed.xml"
    
    # Limpieza básica del XML
    cat "$XML_FILE" | grep -v "DOCTYPE" | grep -v "ENTITY" > "$TMP_XML"
    
    # Reemplazamos el archivo original solo si el temporal existe y tiene contenido
    if [ -s "$TMP_XML" ]; then
        mv "$TMP_XML" "$XML_FILE"
        chmod 644 "$XML_FILE"
    else
        echo -e "${RED}Error: No se pudo reparar el archivo XML.${NC}"
        exit 1
    fi
fi


# ========== REDES DETECTADAS ==========


# Imprime un título en consola con formato de color
echo -e "\n${WHITE}========== REDES DETECTADAS ==========\n${NC}"

# Muestra los encabezados de la tabla para las redes detectadas
printf "%-22s %-20s %-36s %-8s %-6s %-30s\n" "Red" "MAC (punto de acceso)" "Fabricante" "Intens." "Canal" "Encriptación"

# Extraer redes con grep en lugar de xmlstarlet si hay problemas
grep -A5 "<wireless-network type=\"infrastructure\"" "$XML_FILE" | while read -r line; do
    if echo "$line" | grep -q "<SSID>"; then
        essid=$(grep -A2 "<SSID>" <<< "$line" | grep "<essid>" | sed -E 's/.*<essid>(.*)<\/essid>.*/\1/')
        [ -z "$essid" ] && essid="(oculta)"
    fi
    
    if echo "$line" | grep -q "<BSSID>"; then
        bssid=$(echo "$line" | sed -E 's/.*<BSSID>(.*)<\/BSSID>.*/\1/')
    fi
    
    if echo "$line" | grep -q "<last_signal_dbm>"; then
        signal=$(echo "$line" | sed -E 's/.*<last_signal_dbm>(.*)<\/last_signal_dbm>.*/\1/')
    fi
    
    if echo "$line" | grep -q "<channel>"; then
        channel=$(echo "$line" | sed -E 's/.*<channel>(.*)<\/channel>.*/\1/')
    fi
    
    if echo "$line" | grep -q "<encryption>"; then
        enc=$(echo "$line" | sed -E 's/.*<encryption>(.*)<\/encryption>.*/\1/')
    fi
    
    if echo "$line" | grep -q "<manuf>"; then
        fabricante=$(echo "$line" | sed -E 's/.*<manuf>(.*)<\/manuf>.*/\1/')
        [ -z "$fabricante" ] && fabricante="Unknown"
        
        # Imprimir la red una vez que tenemos todos los datos
        printf "%-22s %-20s %-36s %-8s %-6s %-30s\n" "$essid" "$bssid" "$fabricante" "$signal" "$channel" "$enc"
        
        # Resetear variables para la próxima red
        essid=""
        bssid=""
        signal=""
        channel=""
        enc=""
        fabricante=""
    fi
done

#========== CLIENTES DETECTADOS ==========

# Línea en blanco y título para la sección de clientes detectados
echo
echo -e "${WHITE}========== CLIENTES DETECTADOS ==========${NC}"
echo

# Encabezados de la tabla para mostrar clientes conectados o presentes
printf "%-17s %-11s %-36s %-11s %-17s %-20s\n" "MAC" "Conectividad" "Fabricante" "Intensidad" "Asociado a" "Red"

# Extraer clientes con grep en lugar de xmlstarlet
grep -A20 "<wireless-client" "$XML_FILE" | while read -r line; do
    if echo "$line" | grep -q "<client-mac>"; then
        mac=$(echo "$line" | sed -E 's/.*<client-mac>(.*)<\/client-mac>.*/\1/')
        [[ -z "$mac" || "$mac" == "00:00:00:00:00:00" ]] && continue
    fi
    
    if echo "$line" | grep -q "wireless-client type="; then
        tipo=$(echo "$line" | sed -E 's/.*type="([^"]+)".*/\1/')
    fi
    
    if echo "$line" | grep -q "<last_signal_dbm>"; then
        intensidad=$(echo "$line" | sed -E 's/.*<last_signal_dbm>(.*)<\/last_signal_dbm>.*/\1/')
    fi
    
    if echo "$line" | grep -q "<client-manuf>"; then
        fabricante=$(echo "$line" | sed -E 's/.*<client-manuf>(.*)<\/client-manuf>.*/\1/')
        [ -z "$fabricante" ] && fabricante="Unknown"
    fi
    
    # Buscar BSSID asociado y ESSID (esto es más complejo con grep, simplificamos)
    if echo "$line" | grep -q "<BSSID>"; then
        bssid=$(echo "$line" | sed -E 's/.*<BSSID>(.*)<\/BSSID>.*/\1/')
        # Intentamos encontrar el ESSID asociado a este BSSID
        essid=$(grep -A5 "<BSSID>$bssid</BSSID>" "$XML_FILE" | grep -m1 "<essid>" | sed -E 's/.*<essid>(.*)<\/essid>.*/\1/')
        
        # Si tenemos MAC y BSSID, imprimimos el cliente
        if [[ ! -z "$mac" && ! -z "$bssid" ]]; then
            # Define color según la intensidad de señal
            COLOR_INT="${NC}"
            if [[ "$intensidad" =~ ^-?[0-9]+$ ]]; then
                [[ "$intensidad" -ge -50 ]] && COLOR_INT="${YELLOW}"
                [[ "$intensidad" -lt -50 && "$intensidad" -gt -70 ]] && COLOR_INT="${YELLOW}"
                [[ "$intensidad" -le -70 ]] && COLOR_INT="${RED}"
            fi
            
            # Imprime la información del cliente formateada con colores
            printf "%-17s %-11s %-36s ${COLOR_INT}%-11s${NC} %-17s %-20s\n" "$mac" "$tipo" "$fabricante" "$intensidad" "$bssid" "$essid"
            
            # Resetear variables para el próximo cliente
            mac=""
            tipo=""
            intensidad=""
            fabricante=""
            bssid=""
            essid=""
        fi
    fi
done


# --- Restablecer conexión ---

# Detiene el modo monitor de la interfaz utilizada
sudo airmon-ng stop "$INTERFAZ_MONITOR"
echo -e "Modo monitor detenido en $INTERFAZ_MONITOR"

# Reinicia el administrador de red y solicita nueva IP
sudo service NetworkManager restart
sudo dhclient "$INTERFAZ"
echo -e "${YELLOW}Conexión restablecida${NC}"

# --- borra la carpeta temporal creada ---
rm -f "$TMP_DIR/captura-"*